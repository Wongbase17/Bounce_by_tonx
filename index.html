<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <title>Bola Climb - Final</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #f0f0f0;
    }
    canvas {
      border: 1px solid black;
      touch-action: none;
      background: #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <img id="basketImage" src="https://raw.githubusercontent.com/Wongbase17/Abd/refs/heads/main/1758785455798.png" style="display:none;">
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const basketImage = document.getElementById('basketImage');

    let GRAVITY = 0.3;
    const JUMP_FORCE = -8;
    const SPEED = 6;

    let score = 0;
    let level = 1;

    function initialBall() {
      return { x: 200, y: 500, radius: 20, vx: 0, vy: JUMP_FORCE };
    }

    let ball = initialBall();
    let safeLine = { x: 140, y: 580, width: 120, height: 20 };
    const basket = { x: 150, y: 50, width: 100, height: 50 };

    let paths = [];
    let isDrawing = false;
    let currentPath = [];
    const maxLength = 160;
    let gameWon = false;

    function resetGame(showPopup = false) {
      if (showPopup) alert("Game Over!\nScore: " + score);
      ball = initialBall();
      paths = [];
      currentPath = [];
      isDrawing = false;
      gameWon = false;
      level = 1;
      score = 0;
      GRAVITY = 0.3;
      safeLine.width = 120;
    }

    function nextLevel() {
      score += 100;
      level++;
      alert("You Win!\nScore: " + score + "\nNaik ke Level " + level);
      ball = initialBall();
      paths = [];
      currentPath = [];
      isDrawing = false;
      gameWon = false;
      GRAVITY += 0.05;
      safeLine.width = Math.max(60, safeLine.width - 10);
      safeLine.x = (canvas.width - safeLine.width) / 2;
    }

    function getCoordinates(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.type && e.type.startsWith('touch')) {
        const t = e.touches[0] || e.changedTouches[0];
        return { x: t.clientX - rect.left, y: t.clientY - rect.top };
      } else {
        return { x: e.offsetX ?? e.clientX - rect.left, y: e.offsetY ?? e.clientY - rect.top };
      }
    }

    function startDraw(e) { isDrawing = true; currentPath = [getCoordinates(e)]; }
    function moveDraw(e) {
      if (!isDrawing) return;
      const pos = getCoordinates(e);
      currentPath.push(pos);
      if (currentPath.length > maxLength) {
        paths.push([...currentPath]);
        isDrawing = false;
        currentPath = [];
      }
      drawScene();
    }
    function endDraw(e) {
      if (!isDrawing) return;
      currentPath.push(getCoordinates(e));
      if (currentPath.length > 1) paths.push(currentPath);
      isDrawing = false;
      currentPath = [];
      drawScene();
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('touchstart', (e)=>{e.preventDefault();startDraw(e)});
    canvas.addEventListener('touchmove', (e)=>{e.preventDefault();moveDraw(e)});
    canvas.addEventListener('touchend', (e)=>{e.preventDefault();endDraw(e)});

    function collideWithLine(p1, p2) {
      const A = p2.y - p1.y;
      const B = p1.x - p2.x;
      const C = A * p1.x + B * p1.y;
      const denom = Math.sqrt(A*A + B*B);
      if (!denom) return;
      const dist = Math.abs(A * ball.x + B * ball.y - C) / denom;

      if (dist <= ball.radius) {
        const minX = Math.min(p1.x, p2.x) - ball.radius;
        const maxX = Math.max(p1.x, p2.x) + ball.radius;
        const minY = Math.min(p1.y, p2.y) - ball.radius;
        const maxY = Math.max(p1.y, p2.y) + ball.radius;

        if (ball.x >= minX && ball.x <= maxX && ball.y >= minY && ball.y <= maxY && ball.vy > 0) {
          const nx = A / denom, ny = B / denom;
          const dot = ball.vx * nx + ball.vy * ny;
          ball.vx -= 2 * dot * nx;
          ball.vy -= 2 * dot * ny;
          const len = Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
          if (len > 0) {
            ball.vx = (ball.vx / len) * SPEED;
            ball.vy = (ball.vy / len) * SPEED;
          }
        }
      }
    }

    function update() {
      if (gameWon) {
        drawScene();
        requestAnimationFrame(update);
        return;
      }

      ball.vy += GRAVITY;
      ball.x += ball.vx;
      ball.y += ball.vy;

      if (ball.x - ball.radius < 0) {
        ball.x = ball.radius;
        ball.vx = -ball.vx;
      }
      if (ball.x + ball.radius > canvas.width) {
        ball.x = canvas.width - ball.radius;
        ball.vx = -ball.vx;
      }

      if (ball.y + ball.radius >= safeLine.y &&
          ball.y <= safeLine.y + safeLine.height &&
          ball.x >= safeLine.x && ball.x <= safeLine.x + safeLine.width &&
          ball.vy > 0) {
        ball.y = safeLine.y - ball.radius;
        ball.vy = JUMP_FORCE;
      }

      if (ball.y - ball.radius > canvas.height) resetGame(true);

      for (let path of paths) {
        for (let i=0; i<path.length-1; i++) collideWithLine(path[i], path[i+1]);
      }

      if (ball.vy > 0 &&
          ball.x > basket.x && ball.x < basket.x + basket.width &&
          ball.y + ball.radius >= basket.y &&
          ball.y + ball.radius <= basket.y + basket.height) {
        ball.vx = 0;
        ball.vy = 0;
        ball.y = basket.y + basket.height - ball.radius;
        gameWon = true;
        nextLevel();
      }

      drawScene();
      requestAnimationFrame(update);
    }

    function drawScene() {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle = "green";
      ctx.fillRect(safeLine.x, safeLine.y, safeLine.width, safeLine.height);

      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
      ctx.fill();

      if (basketImage.complete) {
        ctx.drawImage(basketImage, basket.x, basket.y, basket.width, basket.height);
      }

      ctx.strokeStyle = "blue";
      ctx.lineWidth = 5;
      for (let path of paths) {
        if (path.length < 2) continue;
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y);
        ctx.stroke();
      }

      if (isDrawing && currentPath.length > 1) {
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (let i=1;i<currentPath.length;i++) ctx.lineTo(currentPath[i].x, currentPath[i].y);
        ctx.stroke();
      }

      ctx.fillStyle = "black";
      ctx.font = "16px Arial";
      ctx.fillText("Score: " + score, 10, 20);
      ctx.fillText("Level: " + level, 10, 40);

      // === Watermark ===
      ctx.font = "14px Arial";
      ctx.fillStyle = "rgba(0,0,0,0.3)"; // semi transparan
      ctx.textAlign = "right";
      ctx.fillText("source by: ton-x cryptoiz", canvas.width - 10, 20);
    }

    update();
  </script>
</body>
</html>